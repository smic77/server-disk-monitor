name: Build and Deploy Server Disk Monitor

# ğŸ¯ DÃ©clencheurs du workflow
on:
  push:
    branches: [ main, develop ]    # Build sur push vers main/develop
    tags: [ 'v*' ]                # Build sur tags version (v1.0.0, v2.1.0, etc.)
  pull_request:
    branches: [ main ]            # Build sur PR vers main

# ğŸŒ Variables globales
env:
  REGISTRY: ghcr.io                          # GitHub Container Registry
  IMAGE_NAME: ${{ github.repository }}      # votre-username/server-disk-monitor

# ğŸ—ï¸ Jobs du workflow
jobs:
  # ===============================================
  # JOB 1: BUILD ET PUSH DE L'IMAGE DOCKER
  # ===============================================
  build-and-push:
    runs-on: ubuntu-latest                   # Machine virtuelle Ubuntu
    permissions:
      contents: read                         # Lire le code source
      packages: write                        # Ã‰crire dans le registry

    steps:
    # ğŸ“¥ Ã‰tape 1: RÃ©cupÃ©rer le code source
    - name: Checkout repository
      uses: actions/checkout@v4
      # â†³ TÃ©lÃ©charge votre code dans la machine virtuelle

    # ğŸ” Ã‰tape 2: Se connecter au registry Docker
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}        # ghcr.io
        username: ${{ github.actor }}        # Votre username GitHub
        password: ${{ secrets.GITHUB_TOKEN }} # Token automatique GitHub
      # â†³ Authentification pour pouvoir push l'image

    # ğŸ·ï¸ Ã‰tape 3: GÃ©nÃ©rer les tags et mÃ©tadonnÃ©es
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch              # Ex: main, develop
          type=ref,event=pr                  # Ex: pr-123
          type=semver,pattern={{version}}    # Ex: v1.0.0 â†’ 1.0.0
          type=semver,pattern={{major}}.{{minor}} # Ex: v1.0.0 â†’ 1.0
          type=raw,value=latest,enable={{is_default_branch}} # latest sur main
      # â†³ CrÃ©e automatiquement les tags selon le contexte

    # ğŸ”§ Ã‰tape 4: Configurer Docker Buildx (build avancÃ©)
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      # â†³ Active les fonctionnalitÃ©s avancÃ©es (multi-arch, cache)

    # ğŸ³ Ã‰tape 5: Build et push de l'image Docker
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .                           # Dossier de build (racine du repo)
        platforms: linux/amd64,linux/arm64  # Multi-architecture
        push: true                           # Push automatique aprÃ¨s build
        tags: ${{ steps.meta.outputs.tags }} # Tags gÃ©nÃ©rÃ©s Ã  l'Ã©tape 3
        labels: ${{ steps.meta.outputs.labels }} # MÃ©tadonnÃ©es
        cache-from: type=gha                 # Cache depuis GitHub Actions
        cache-to: type=gha,mode=max          # Sauvegarde du cache
      # â†³ Build l'image et la pousse vers ghcr.io

    # ğŸ“¦ Ã‰tape 6: GÃ©nÃ©rer les artefacts de dÃ©ploiement
    - name: Generate deployment artifact
      run: |
        mkdir -p deployment
        envsubst < docker-compose.portainer.yml > deployment/docker-compose.yml
        cp portainer-stack.yml deployment/
        echo "IMAGE_TAG=${{ steps.meta.outputs.version }}" > deployment/.env
      env:
        IMAGE_NAME: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      # â†³ PrÃ©pare les fichiers de dÃ©ploiement avec les bonnes variables

    # ğŸ“¤ Ã‰tape 7: Upload des artefacts
    - name: Upload deployment artifacts
      uses: actions/upload-artifact@v3
      with:
        name: deployment-files
        path: deployment/
      # â†³ Rend les fichiers de dÃ©ploiement tÃ©lÃ©chargeables

  # ===============================================
  # JOB 2: SCAN DE SÃ‰CURITÃ‰
  # ===============================================
  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-push                    # Attend la fin du build
    if: github.event_name != 'pull_request' # Pas sur les PR (Ã©conomise du temps)
    
    steps:
    # ğŸ” Ã‰tape 1: Scanner les vulnÃ©rabilitÃ©s
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: 'sarif'                      # Format pour GitHub Security
        output: 'trivy-results.sarif'
      # â†³ Analyse l'image pour dÃ©tecter les vulnÃ©rabilitÃ©s

    # ğŸ“Š Ã‰tape 2: Upload des rÃ©sultats de sÃ©curitÃ©
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()                           # Toujours exÃ©cuter mÃªme si scan Ã©choue
      with:
        sarif_file: 'trivy-results.sarif'
      # â†³ Affiche les rÃ©sultats dans l'onglet Security de GitHub
